import{d as f,M as a,a as n,S as g,an as r,W as o,c as u,V as c}from"./three-DTQjiZ7L.js";class I{constructor(e){this.engine=e,this.hazards=[],this.hazardTypes={SPIKE_TRAP:"spike_trap",POISON_CLOUD:"poison_cloud",FIRE_ZONE:"fire_zone",LIGHTNING_TRAP:"lightning_trap",ICE_PATCH:"ice_patch",LAVA_POOL:"lava_pool",ARROW_TRAP:"arrow_trap",BLADE_SPINNER:"blade_spinner"},this.enabled=!0}init(){}spawnHazard(e,t,s="forest"){const i=this.createHazard(e,t,s);return i?(this.hazards.push(i),i):null}createHazard(e,t,s){switch(e){case this.hazardTypes.SPIKE_TRAP:return this.createSpikeTrap(t);case this.hazardTypes.POISON_CLOUD:return this.createPoisonCloud(t);case this.hazardTypes.FIRE_ZONE:return this.createFireZone(t);case this.hazardTypes.LIGHTNING_TRAP:return this.createLightningTrap(t);case this.hazardTypes.ICE_PATCH:return this.createIcePatch(t);case this.hazardTypes.LAVA_POOL:return this.createLavaPool(t);case this.hazardTypes.ARROW_TRAP:return this.createArrowTrap(t);case this.hazardTypes.BLADE_SPINNER:return this.createBladeSpinner(t);default:return null}}createSpikeTrap(e){const t=new f(1.5,1.5,.2,8),s=new a({color:8947848,metalness:.6,roughness:.4}),i=new n(t,s);return i.position.copy(e),i.position.y=.1,this.engine.scene.add(i),{type:this.hazardTypes.SPIKE_TRAP,mesh:i,position:e.clone(),radius:1.5,damage:15,damageInterval:.5,lastDamageTime:0,active:!1,activationDelay:1,timer:0,duration:2,cooldown:3,state:"idle"}}createPoisonCloud(e){const t=new g(2,16,16),s=new a({color:65280,transparent:!0,opacity:.3,emissive:65280,emissiveIntensity:.5}),i=new n(t,s);return i.position.copy(e),i.position.y=1,this.engine.scene.add(i),{type:this.hazardTypes.POISON_CLOUD,mesh:i,position:e.clone(),radius:2,damage:8,damageInterval:1,lastDamageTime:0,active:!0,lifetime:15,timer:0,statusEffect:"poison"}}createFireZone(e){const t=new r(2.5,32),s=new a({color:16729088,transparent:!0,opacity:.6,emissive:16729088,emissiveIntensity:1,side:o}),i=new n(t,s);return i.position.copy(e),i.position.y=.05,i.rotation.x=-Math.PI/2,this.engine.scene.add(i),{type:this.hazardTypes.FIRE_ZONE,mesh:i,position:e.clone(),radius:2.5,damage:20,damageInterval:.5,lastDamageTime:0,active:!0,lifetime:10,timer:0,particleTimer:0}}createLightningTrap(e){const t=new f(.3,.3,3,8),s=new a({color:16776960,emissive:16776960,emissiveIntensity:2}),i=new n(t,s);return i.position.copy(e),i.position.y=1.5,this.engine.scene.add(i),{type:this.hazardTypes.LIGHTNING_TRAP,mesh:i,position:e.clone(),radius:3,damage:35,damageInterval:2.5,lastDamageTime:0,active:!1,chargeTime:2,timer:0,state:"charging"}}createIcePatch(e){const t=new r(3,32),s=new a({color:11193599,transparent:!0,opacity:.7,metalness:.8,roughness:.1,side:o}),i=new n(t,s);return i.position.copy(e),i.position.y=.02,i.rotation.x=-Math.PI/2,this.engine.scene.add(i),{type:this.hazardTypes.ICE_PATCH,mesh:i,position:e.clone(),radius:3,damage:5,damageInterval:1,lastDamageTime:0,active:!0,slowEffect:.5,lifetime:20,timer:0}}createLavaPool(e){const t=new r(2,32),s=new a({color:16724736,emissive:16724736,emissiveIntensity:1.5,side:o}),i=new n(t,s);return i.position.copy(e),i.position.y=.1,i.rotation.x=-Math.PI/2,this.engine.scene.add(i),{type:this.hazardTypes.LAVA_POOL,mesh:i,position:e.clone(),radius:2,damage:30,damageInterval:.3,lastDamageTime:0,active:!0,permanent:!0}}createArrowTrap(e){const t=new u(.5,2,.5),s=new a({color:9127187}),i=new n(t,s);return i.position.copy(e),i.position.y=1,this.engine.scene.add(i),{type:this.hazardTypes.ARROW_TRAP,mesh:i,position:e.clone(),radius:1,damage:25,active:!1,fireInterval:3,timer:0,projectileSpeed:15,direction:new c(1,0,0)}}createBladeSpinner(e){const t=new u(3,.2,.5),s=new a({color:13421772,metalness:1,roughness:.2}),i=new n(t,s);return i.position.copy(e),i.position.y=1,this.engine.scene.add(i),{type:this.hazardTypes.BLADE_SPINNER,mesh:i,position:e.clone(),radius:2,damage:40,damageInterval:.5,lastDamageTime:0,active:!0,rotationSpeed:3,permanent:!0}}update(e){if(!this.enabled)return;const t=Date.now()/1e3;for(let s=this.hazards.length-1;s>=0;s--){const i=this.hazards[s];this.updateHazardState(i,e,t),this.checkPlayerCollision(i,t),this.checkEnemyCollisions(i,t),this.shouldRemoveHazard(i)&&this.removeHazard(s)}}updateHazardState(e,t,s){switch(e.timer+=t,e.type){case this.hazardTypes.SPIKE_TRAP:this.updateSpikeTrap(e,t);break;case this.hazardTypes.POISON_CLOUD:this.updatePoisonCloud(e,t);break;case this.hazardTypes.FIRE_ZONE:this.updateFireZone(e,t);break;case this.hazardTypes.LIGHTNING_TRAP:this.updateLightningTrap(e,t);break;case this.hazardTypes.ARROW_TRAP:this.updateArrowTrap(e,t);break;case this.hazardTypes.BLADE_SPINNER:this.updateBladeSpinner(e,t);break}}updateSpikeTrap(e,t){const s=this.engine.player;if(!s||!s.mesh)return;e.position.distanceTo(s.mesh.position)<e.radius+2&&e.state==="idle"&&(e.state="activating",e.timer=0),e.state==="activating"?e.timer>e.activationDelay&&(e.state="active",e.active=!0,e.timer=0,e.mesh.position.y=.5):e.state==="active"?e.timer>e.duration&&(e.state="retracting",e.active=!1,e.timer=0,e.mesh.position.y=.1):e.state==="retracting"&&e.timer>e.cooldown&&(e.state="idle",e.timer=0)}updatePoisonCloud(e,t){const s=1+Math.sin(e.timer*2)*.1;e.mesh.scale.set(s,s,s)}updateFireZone(e,t){if(e.particleTimer+=t,e.particleTimer>.1&&(e.particleTimer=0,this.engine.particleSystem)){const s=e.position.clone();s.x+=(Math.random()-.5)*e.radius*2,s.z+=(Math.random()-.5)*e.radius*2,this.engine.particleSystem.createFireParticle(s)}e.mesh.material.emissiveIntensity=.8+Math.sin(e.timer*10)*.3}updateLightningTrap(e,t){e.state==="charging"?(e.mesh.material.emissiveIntensity=2+Math.sin(e.timer*15)*1,e.timer>e.chargeTime&&(e.state="zapping",e.active=!0,e.timer=0,e.mesh.scale.set(1,3,1))):e.state==="zapping"?e.timer>.2&&(e.state="cooldown",e.active=!1,e.timer=0,e.mesh.scale.set(1,1,1)):e.state==="cooldown"&&e.timer>2&&(e.state="charging",e.timer=0)}updateArrowTrap(e,t){e.timer>e.fireInterval&&(e.timer=0,this.fireArrow(e))}updateBladeSpinner(e,t){e.mesh.rotation.y+=e.rotationSpeed*t}fireArrow(e){const t=this.engine.player;if(!t||!t.mesh)return;new c().subVectors(t.mesh.position,e.position).normalize(),this.engine.audioSystem&&this.engine.audioSystem.playSoundEffect("projectile"),e.position.distanceTo(t.mesh.position)<15&&setTimeout(()=>{t.takeDamage&&t.takeDamage(e.damage)},200)}checkPlayerCollision(e,t){if(!e.active)return;const s=this.engine.player;if(!s||!s.mesh)return;e.position.distanceTo(s.mesh.position)<e.radius&&t-e.lastDamageTime>e.damageInterval&&(e.lastDamageTime=t,s.takeDamage&&s.takeDamage(e.damage),e.statusEffect&&this.applyStatusEffect(s,e.statusEffect),this.engine.audioSystem&&this.engine.audioSystem.playSoundEffect("hit"))}checkEnemyCollisions(e,t){if(e.active&&this.engine.enemies)for(const s of this.engine.enemies){if(!s.mesh||s.isDead)continue;e.position.distanceTo(s.mesh.position)<e.radius&&t-e.lastDamageTime>e.damageInterval&&s.takeDamage&&s.takeDamage(e.damage*.5)}}applyStatusEffect(e,t){}shouldRemoveHazard(e){return e.permanent?!1:!!(e.lifetime&&e.timer>e.lifetime)}removeHazard(e){const t=this.hazards[e];t.mesh&&(this.engine.scene.remove(t.mesh),t.mesh.geometry.dispose(),t.mesh.material.dispose()),this.hazards.splice(e,1)}spawnRandomHazards(e,t,s,i="forest"){const m=Object.values(this.hazardTypes);for(let p=0;p<s;p++){const l=Math.random()*Math.PI*2,h=Math.random()*t,d=new c(e.x+Math.cos(l)*h,e.y,e.z+Math.sin(l)*h),y=m[Math.floor(Math.random()*m.length)];this.spawnHazard(y,d,i)}}clearAll(){for(let e=this.hazards.length-1;e>=0;e--)this.removeHazard(e)}getHazardsInArea(e,t){return this.hazards.filter(s=>s.position.distanceTo(e)<t+s.radius)}}export{I as EnvironmentalHazards};
