class a{constructor(){this.puzzleTypes={MATCH3:"match3",SLIDING:"sliding",PATTERN:"pattern",LOGIC:"logic",RUNE:"rune",COMBINATION:"combination"},this.currentPuzzle=null,this.isPlaying=!1,this.match3Grid=null,this.match3Size=8,this.match3Colors=6,this.stats={puzzlesSolved:0,match3Played:0,slidingPuzzlesSolved:0,patternsSolved:0,logicPuzzlesSolved:0,runePuzzlesSolved:0,totalMoves:0,bestTime:1/0,dailyStreak:0},this.rewards={puzzleSolved:100,perfectSolution:500,dailyComplete:1e3,firstTime:2e3}}startMatch3(t=8,e=6,s=30){return this.currentPuzzle={type:this.puzzleTypes.MATCH3,size:t,colors:e,movesLimit:s,movesUsed:0,score:0,combo:0,startTime:Date.now()},this.match3Grid=this.createMatch3Grid(t,e),this.isPlaying=!0,this.stats.match3Played++,this.match3Grid}createMatch3Grid(t,e){const s=[];for(let i=0;i<t;i++){s[i]=[];for(let r=0;r<t;r++)s[i][r]={color:Math.floor(Math.random()*e),row:i,col:r,matched:!1}}return this.clearInitialMatches(s,e),s}clearInitialMatches(t,e){let s=!0;for(;s;){s=!1;for(let i=0;i<t.length;i++)for(let r=0;r<t[i].length;r++)this.checkMatch(t,i,r)&&(t[i][r].color=Math.floor(Math.random()*e),s=!0)}}swapMatch3(t,e,s,i){if(!this.isPlaying||!this.match3Grid||!(Math.abs(t-s)===1&&e===i||Math.abs(e-i)===1&&t===s))return!1;const l=this.match3Grid[t][e].color;this.match3Grid[t][e].color=this.match3Grid[s][i].color,this.match3Grid[s][i].color=l;const h=this.findAllMatches();if(h.length>0)return this.currentPuzzle.movesUsed++,this.processMatches(h),!0;{const o=this.match3Grid[t][e].color;return this.match3Grid[t][e].color=this.match3Grid[s][i].color,this.match3Grid[s][i].color=o,!1}}findAllMatches(){const t=[];for(let e=0;e<this.match3Grid.length;e++){let s=1,i=this.match3Grid[e][0].color;for(let r=1;r<this.match3Grid[e].length;r++)this.match3Grid[e][r].color===i?s++:(s>=3&&t.push({type:"horizontal",row:e,startCol:r-s,count:s,color:i}),s=1,i=this.match3Grid[e][r].color);s>=3&&t.push({type:"horizontal",row:e,startCol:this.match3Grid[e].length-s,count:s,color:i})}for(let e=0;e<this.match3Grid[0].length;e++){let s=1,i=this.match3Grid[0][e].color;for(let r=1;r<this.match3Grid.length;r++)this.match3Grid[r][e].color===i?s++:(s>=3&&t.push({type:"vertical",col:e,startRow:r-s,count:s,color:i}),s=1,i=this.match3Grid[r][e].color);s>=3&&t.push({type:"vertical",col:e,startRow:this.match3Grid.length-s,count:s,color:i})}return t}checkMatch(t,e,s){const i=t[e][s].color;let r=1;s>0&&t[e][s-1].color===i&&r++,s<t[e].length-1&&t[e][s+1].color===i&&r++;let l=1;return e>0&&t[e-1][s].color===i&&l++,e<t.length-1&&t[e+1][s].color===i&&l++,r>=3||l>=3}processMatches(t){for(const l of t)if(l.type==="horizontal")for(let h=0;h<l.count;h++)this.match3Grid[l.row][l.startCol+h].matched=!0;else for(let h=0;h<l.count;h++)this.match3Grid[l.startRow+h][l.col].matched=!0;const e=100,s=1+this.currentPuzzle.combo*.5,i=t.reduce((l,h)=>l+h.count*e,0),r=Math.floor(i*s);this.currentPuzzle.score+=r,this.currentPuzzle.combo++,this.removeMatchedTiles(),this.applyGravity(),this.fillEmptySpaces(),setTimeout(()=>{const l=this.findAllMatches();l.length>0?this.processMatches(l):(this.currentPuzzle.combo=0,this.checkMatch3Complete())},300)}removeMatchedTiles(){for(let t=0;t<this.match3Grid.length;t++)for(let e=0;e<this.match3Grid[t].length;e++)this.match3Grid[t][e].matched&&(this.match3Grid[t][e]=null)}applyGravity(){for(let t=0;t<this.match3Grid[0].length;t++)for(let e=this.match3Grid.length-1;e>=0;e--)if(this.match3Grid[e][t]===null){for(let s=e-1;s>=0;s--)if(this.match3Grid[s][t]!==null){this.match3Grid[e][t]=this.match3Grid[s][t],this.match3Grid[e][t].row=e,this.match3Grid[s][t]=null;break}}}fillEmptySpaces(){for(let t=0;t<this.match3Grid.length;t++)for(let e=0;e<this.match3Grid[t].length;e++)this.match3Grid[t][e]===null&&(this.match3Grid[t][e]={color:Math.floor(Math.random()*this.currentPuzzle.colors),row:t,col:e,matched:!1})}checkMatch3Complete(){this.currentPuzzle.movesUsed>=this.currentPuzzle.movesLimit&&this.completeMatch3()}completeMatch3(){this.isPlaying=!1;const t={score:this.currentPuzzle.score,movesUsed:this.currentPuzzle.movesUsed,movesLimit:this.currentPuzzle.movesLimit,time:Date.now()-this.currentPuzzle.startTime};return this.stats.puzzlesSolved++,this.stats.totalMoves+=this.currentPuzzle.movesUsed,window.gameEngine&&window.gameEngine.eventBus?.emit("puzzle:match3Complete",t),t}startSlidingPuzzle(t=4,e=null){this.currentPuzzle={type:this.puzzleTypes.SLIDING,size:t,moves:0,startTime:Date.now(),imageUrl:e};const s=this.createSlidingGrid(t);return this.shuffleSlidingGrid(s),this.isPlaying=!0,this.currentPuzzle.grid=s,s}createSlidingGrid(t){const e=[];let s=1;for(let i=0;i<t;i++){e[i]=[];for(let r=0;r<t;r++)e[i][r]=i===t-1&&r===t-1?0:s++}return e}shuffleSlidingGrid(t){const e=t.length*t.length*100;for(let s=0;s<e;s++){const[i,r]=this.findEmptyTile(t),l=this.getValidSlidingMoves(t,i,r);if(l.length>0){const h=l[Math.floor(Math.random()*l.length)];this.slideTile(t,h.row,h.col)}}}findEmptyTile(t){for(let e=0;e<t.length;e++)for(let s=0;s<t[e].length;s++)if(t[e][s]===0)return[e,s];return null}getValidSlidingMoves(t,e,s){const i=[],r=[[-1,0],[1,0],[0,-1],[0,1]];for(const[l,h]of r){const o=e+l,n=s+h;o>=0&&o<t.length&&n>=0&&n<t[0].length&&i.push({row:o,col:n})}return i}slideTile(t,e,s){const[i,r]=this.findEmptyTile(t);return Math.abs(e-i)===1&&s===r||Math.abs(s-r)===1&&e===i?(t[i][r]=t[e][s],t[e][s]=0,this.currentPuzzle&&(this.currentPuzzle.moves++,this.stats.totalMoves++,this.isSlidingPuzzleSolved(t)&&this.completeSlidingPuzzle()),!0):!1}isSlidingPuzzleSolved(t){let e=1;for(let s=0;s<t.length;s++)for(let i=0;i<t[s].length;i++){if(s===t.length-1&&i===t[s].length-1)return t[s][i]===0;if(t[s][i]!==e++)return!1}return!0}completeSlidingPuzzle(){this.isPlaying=!1;const t=Date.now()-this.currentPuzzle.startTime,e={moves:this.currentPuzzle.moves,time:t,size:this.currentPuzzle.size};this.stats.puzzlesSolved++,this.stats.slidingPuzzlesSolved++,this.stats.bestTime=Math.min(this.stats.bestTime,t);const s=this.rewards.puzzleSolved+Math.max(0,1e3-this.currentPuzzle.moves*10);return window.gameEngine&&window.gameEngine.eventBus?.emit("puzzle:slidingComplete",{...e,reward:s}),e}startRunePuzzle(t=3){const e=this.generateRuneSequence(t);return this.currentPuzzle={type:this.puzzleTypes.RUNE,runes:e,correctSequence:[...e].sort(),playerSequence:[],attempts:0,maxAttempts:5,startTime:Date.now()},this.isPlaying=!0,{runes:e.sort(),maxAttempts:this.currentPuzzle.maxAttempts}}generateRuneSequence(t){const e=["fire","water","earth","air","light","dark","nature","arcane"],s=[];for(let i=0;i<t;i++)s.push(e[Math.floor(Math.random()*e.length)]);return s}submitRuneSequence(t){return this.isPlaying?(this.currentPuzzle.attempts++,JSON.stringify(t)===JSON.stringify(this.currentPuzzle.correctSequence)?(this.completeRunePuzzle(!0),{success:!0,correct:!0}):this.currentPuzzle.attempts>=this.currentPuzzle.maxAttempts?(this.completeRunePuzzle(!1),{success:!1,attemptsExceeded:!0}):{success:!1,attemptsRemaining:this.currentPuzzle.maxAttempts-this.currentPuzzle.attempts}):!1}completeRunePuzzle(t){this.isPlaying=!1;const e={success:t,attempts:this.currentPuzzle.attempts,time:Date.now()-this.currentPuzzle.startTime};if(t){this.stats.puzzlesSolved++,this.stats.runePuzzlesSolved++;const s=this.rewards.puzzleSolved*(1+(this.currentPuzzle.maxAttempts-this.currentPuzzle.attempts)*.5);e.reward=s}return window.gameEngine&&window.gameEngine.eventBus?.emit("puzzle:runeComplete",e),e}getStats(){return{...this.stats}}reset(){this.currentPuzzle=null,this.isPlaying=!1,this.match3Grid=null}}export{a as PuzzleGameSystem};
