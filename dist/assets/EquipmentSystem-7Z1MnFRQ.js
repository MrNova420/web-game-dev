class l{constructor(t,e){this.stats=t,this.ui=e,this.equipped=new Map,this.slots=["head","chest","legs","hands","feet","weapon","offhand","neck","ring1","ring2","trinket1","trinket2"],this.rarities={common:{color:"#9d9d9d",multiplier:1},uncommon:{color:"#1eff00",multiplier:1.2},rare:{color:"#0070dd",multiplier:1.5},epic:{color:"#a335ee",multiplier:2},legendary:{color:"#ff8000",multiplier:3},mythic:{color:"#e6cc80",multiplier:4},artifact:{color:"#e5cc80",multiplier:5}},this.itemSets=new Map}initializeEquipment(t){const e={};for(const s of this.slots)e[s]=null;return this.equipped.set(t,e),e}equipItem(t,e,s){const i=this.equipped.get(t);if(!i)return{success:!1,reason:"Player not found"};if(!this.slots.includes(s))return{success:!1,reason:"Invalid slot"};const r=this.checkRequirements(t,e);if(!r.success)return r;const n=i[s];return n&&this.removeItemStats(t,n),i[s]=e,this.applyItemStats(t,e),this.updateSetBonuses(t),this.ui&&this.ui.updateEquipmentDisplay(t,s,e),{success:!0,equipped:e,unequipped:n,slot:s}}unequipItem(t,e){const s=this.equipped.get(t);if(!s)return{success:!1};const i=s[e];return i?(s[e]=null,this.removeItemStats(t,i),this.updateSetBonuses(t),{success:!0,item:i,slot:e}):{success:!1,reason:"No item equipped"}}checkRequirements(t,e){if(!e.requirements)return{success:!0};const s=e.requirements;if(s.level&&(this.stats.players.get(t)?.level||1)<s.level)return{success:!1,reason:`Requires level ${s.level}`};if(s.stats){for(const[i,r]of Object.entries(s.stats))if(this.stats.getTotalStat(t,i)<r)return{success:!1,reason:`Requires ${r} ${i}`}}return s.class,{success:!0}}applyItemStats(t,e){if(!e.stats)return;const s=`equipment_${e.id}`;this.stats.addModifier(t,s,e.stats)}removeItemStats(t,e){if(!e.stats)return;const s=`equipment_${e.id}`;this.stats.removeModifier(t,s)}updateSetBonuses(t){const e=this.equipped.get(t);if(!e)return;const s=new Map;for(const i of Object.values(e))i&&i.setId&&s.set(i.setId,(s.get(i.setId)||0)+1);for(const[i,r]of this.itemSets.entries())r.appliedTo.has(t)&&this.removeSetBonus(t,i);for(const[i,r]of s.entries()){const n=this.getItemSet(i);if(n)for(const[o,u]of Object.entries(n.bonuses))r>=parseInt(o)&&this.applySetBonus(t,i,u)}}applySetBonus(t,e,s){const i=`set_${e}`;s.stats&&this.stats.addModifier(t,i,s.stats);let r=this.itemSets.get(e);r||(r={id:e,bonuses:{},appliedTo:new Set},this.itemSets.set(e,r)),r.appliedTo.add(t)}removeSetBonus(t,e){const s=`set_${e}`;this.stats.removeModifier(t,s);const i=this.itemSets.get(e);i&&i.appliedTo.delete(t)}getItemSet(t){return{id:t,name:"Dragon Slayer Set",bonuses:{2:{stats:{strength:20,vitality:15}},4:{stats:{strength:40,vitality:30,attack:50}},6:{stats:{strength:100,vitality:75,attack:150},special:"dragon_slayer"}}}}getEquippedItems(t){return this.equipped.get(t)}getEquipmentPower(t){const e=this.equipped.get(t);if(!e)return 0;let s=0;for(const i of Object.values(e)){if(!i)continue;const r=this.calculateItemPower(i);s+=r}return s}calculateItemPower(t){if(!t.stats)return 0;let e=0;const s=this.rarities[t.rarity]?.multiplier||1;for(const i of Object.values(t.stats))e+=Math.abs(i);return Math.floor(e*s)}compareItems(t,e){const s=this.calculateItemPower(t),i=this.calculateItemPower(e),r={powerDiff:i-s,isBetter:i>s,isWorse:i<s,statComparison:{}},n=new Set([...Object.keys(t.stats||{}),...Object.keys(e.stats||{})]);for(const o of n){const u=(t.stats||{})[o]||0,a=(e.stats||{})[o]||0;r.statComparison[o]={current:u,new:a,diff:a-u}}return r}damageEquipment(t,e,s){const i=this.equipped.get(t);if(!i)return;const r=i[e];!r||!r.durability||(r.durability.current=Math.max(0,r.durability.current-s),r.durability.current===0&&this.onItemBroken(t,e,r))}repairEquipment(t,e,s=null){const i=this.equipped.get(t);if(!i)return;const r=i[e];if(!(!r||!r.durability))return s===null?r.durability.current=r.durability.max:r.durability.current=Math.min(r.durability.max,r.durability.current+s),r.durability.current}onItemBroken(t,e,s){this.removeItemStats(t,s),this.ui&&this.ui.showNotification(`${s.name} has broken!`,"warning")}}export{l as EquipmentSystem};
