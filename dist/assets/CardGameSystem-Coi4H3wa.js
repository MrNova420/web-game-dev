import{l}from"./index-Bf-_4h4A.js";import"./three-DTQjiZ7L.js";import"./cannon-DPZWuR6y.js";class m{constructor(){this.isPlaying=!1,this.currentMatch=null,this.cardDatabase=this.initializeCardDatabase(),this.playerCollection=new Map,this.playerDecks=[],this.activeDeck=null,this.settings={deckSize:30,maxHandSize:10,startingMana:1,maxMana:10,startingHand:3,playerHealth:30},this.stats={matchesPlayed:0,matchesWon:0,cardsCollected:0,cardsPlayed:0,damageDealt:0,healingDone:0}}initializeCardDatabase(){const t=new Map;return this.addCreatureCards(t),this.addSpellCards(t),this.addArtifactCards(t),t}addCreatureCards(t){const e=[{id:"smoke_sprite",name:"Smoke Sprite",cost:1,attack:1,health:1,rarity:"common",ability:null},{id:"herb_guardian",name:"Herb Guardian",cost:2,attack:2,health:2,rarity:"common",ability:null},{id:"crystal_golem",name:"Crystal Golem",cost:3,attack:3,health:3,rarity:"common",ability:null},{id:"smoke_wolf",name:"Smoke Wolf",cost:3,attack:3,health:2,rarity:"uncommon",ability:{type:"charge"}},{id:"fungal_beast",name:"Fungal Beast",cost:4,attack:4,health:4,rarity:"uncommon",ability:{type:"taunt"}},{id:"thunder_drake",name:"Thunder Drake",cost:5,attack:5,health:4,rarity:"rare",ability:{type:"battlecry",effect:"deal_2_damage"}},{id:"shadow_assassin",name:"Shadow Assassin",cost:4,attack:4,health:2,rarity:"rare",ability:{type:"stealth"}},{id:"ethereal_phoenix",name:"Ethereal Phoenix",cost:6,attack:6,health:5,rarity:"epic",ability:{type:"deathrattle",effect:"resummon"}},{id:"void_dragon",name:"Void Dragon",cost:8,attack:8,health:8,rarity:"epic",ability:{type:"immune"}},{id:"smoke_siren",name:"Smoke Siren",cost:7,attack:5,health:7,rarity:"legendary",ability:{type:"battlecry",effect:"charm_enemy"}},{id:"omega_dragon",name:"Omega Dragon",cost:10,attack:12,health:12,rarity:"legendary",ability:{type:"battlecry",effect:"destroy_all"}}];for(const a of e)t.set(a.id,{...a,type:"creature"})}addSpellCards(t){const e=[{id:"smoke_blast",name:"Smoke Blast",cost:2,rarity:"common",effect:{type:"damage",value:3,target:"enemy"}},{id:"herb_heal",name:"Herb Heal",cost:2,rarity:"common",effect:{type:"heal",value:5,target:"player"}},{id:"essence_drain",name:"Essence Drain",cost:3,rarity:"uncommon",effect:{type:"damage",value:4,target:"enemy",lifesteal:!0}},{id:"crystal_shield",name:"Crystal Shield",cost:3,rarity:"uncommon",effect:{type:"shield",value:5,target:"player"}},{id:"fireball",name:"Fireball",cost:4,rarity:"rare",effect:{type:"damage",value:6,target:"any"}},{id:"mass_heal",name:"Mass Heal",cost:5,rarity:"rare",effect:{type:"heal_all",value:4}},{id:"lightning_storm",name:"Lightning Storm",cost:6,rarity:"epic",effect:{type:"damage_all_enemies",value:4}},{id:"time_warp",name:"Time Warp",cost:5,rarity:"epic",effect:{type:"extra_turn"}},{id:"omega_blast",name:"Omega Blast",cost:10,rarity:"legendary",effect:{type:"damage",value:20,target:"enemy"}},{id:"resurrection",name:"Resurrection",cost:8,rarity:"legendary",effect:{type:"revive_all_friendly"}}];for(const a of e)t.set(a.id,{...a,type:"spell"})}addArtifactCards(t){const e=[{id:"smoke_ring",name:"Smoke Ring",cost:2,rarity:"uncommon",effect:{type:"draw_card_each_turn"}},{id:"herb_pouch",name:"Herb Pouch",cost:3,rarity:"uncommon",effect:{type:"gain_mana"}},{id:"crystal_amulet",name:"Crystal Amulet",cost:4,rarity:"rare",effect:{type:"reduce_spell_cost",value:1}},{id:"staff_of_power",name:"Staff of Power",cost:5,rarity:"epic",effect:{type:"spell_damage_boost",value:2}},{id:"crown_of_emberveil",name:"Crown of Emberveil",cost:7,rarity:"legendary",effect:{type:"win_condition",turns:5}}];for(const a of e)t.set(a.id,{...a,type:"artifact"})}createDeck(t,e){if(e.length!==this.settings.deckSize)return l.warn(`Deck must contain exactly ${this.settings.deckSize} cards`),null;const a={id:Math.random().toString(36),name:t,cards:e.map(s=>this.cardDatabase.get(s)),wins:0,losses:0,createdAt:Date.now()};return this.playerDecks.push(a),a}startMatch(t,e){return this.isPlaying=!0,this.activeDeck=t,this.currentMatch={player:this.createPlayer(t),opponent:this.createPlayer(e),turn:1,currentPlayer:"player",startTime:Date.now()},this.drawStartingHand(this.currentMatch.player),this.drawStartingHand(this.currentMatch.opponent),this.stats.matchesPlayed++,this.currentMatch}createPlayer(t){return{health:this.settings.playerHealth,maxHealth:this.settings.playerHealth,mana:this.settings.startingMana,maxMana:this.settings.startingMana,deck:[...t.cards].sort(()=>Math.random()-.5),hand:[],board:[],graveyard:[],artifacts:[]}}drawStartingHand(t){for(let e=0;e<this.settings.startingHand;e++)this.drawCard(t)}drawCard(t){if(t.deck.length===0)return t.health-=t.hand.length+1,null;if(t.hand.length>=this.settings.maxHandSize)return t.deck.shift(),null;const e=t.deck.shift();return t.hand.push(e),e}playCard(t,e=null){if(!this.isPlaying)return!1;const a=this.currentMatch[this.currentMatch.currentPlayer],s=a.hand[t];return!s||a.mana<s.cost?!1:(a.mana-=s.cost,a.hand.splice(t,1),this.executeCard(s,a,e),this.stats.cardsPlayed++,!0)}executeCard(t,e,a){const s=e===this.currentMatch.player?this.currentMatch.opponent:this.currentMatch.player;switch(t.type){case"creature":e.board.push({...t,currentAttack:t.attack,currentHealth:t.health,canAttack:t.ability?.type==="charge",summoned:!0}),t.ability?.type==="battlecry"&&this.executeBattlecry(t.ability.effect,s);break;case"spell":this.executeSpell(t,e,s,a),e.graveyard.push(t);break;case"artifact":e.artifacts.push(t);break}}executeBattlecry(t,e){switch(t){case"deal_2_damage":e.health-=2,this.stats.damageDealt+=2;break;case"charm_enemy":if(e.board.length>0){const a=e.board.pop();this.currentMatch.player.board.push(a)}break;case"destroy_all":e.board=[];break}}executeSpell(t,e,a,s){const r=t.effect;switch(r.type){case"damage":(r.target==="enemy"||s==="opponent")&&(a.health-=r.value,this.stats.damageDealt+=r.value,r.lifesteal&&(e.health=Math.min(e.maxHealth,e.health+r.value),this.stats.healingDone+=r.value));break;case"heal":e.health=Math.min(e.maxHealth,e.health+r.value),this.stats.healingDone+=r.value;break;case"damage_all_enemies":for(const n of a.board)n.currentHealth-=r.value;a.board=a.board.filter(n=>n.currentHealth>0);break;case"heal_all":for(const n of e.board)n.currentHealth=Math.min(n.health,n.currentHealth+r.value);this.stats.healingDone+=r.value*e.board.length;break}}attackWithCreature(t,e){if(!this.isPlaying)return!1;const a=this.currentMatch[this.currentMatch.currentPlayer],s=a===this.currentMatch.player?this.currentMatch.opponent:this.currentMatch.player,r=a.board[t];if(!r||!r.canAttack)return!1;if(r.canAttack=!1,e==="face")s.health-=r.currentAttack,this.stats.damageDealt+=r.currentAttack;else{const n=s.board[e];if(!n)return!1;r.currentHealth-=n.currentAttack,n.currentHealth-=r.currentAttack,r.currentHealth<=0&&(a.board.splice(t,1),a.graveyard.push(r)),n.currentHealth<=0&&(s.board.splice(e,1),s.graveyard.push(n))}return!0}endTurn(){if(!this.isPlaying)return;this.currentMatch.currentPlayer=this.currentMatch.currentPlayer==="player"?"opponent":"player",this.currentMatch.currentPlayer==="player"&&this.currentMatch.turn++;const t=this.currentMatch[this.currentMatch.currentPlayer];t.maxMana=Math.min(this.settings.maxMana,t.maxMana+1),t.mana=t.maxMana,this.drawCard(t);for(const e of t.board)e.canAttack=!0;this.checkGameEnd()}checkGameEnd(){this.currentMatch.player.health<=0?this.endMatch(!1):this.currentMatch.opponent.health<=0&&this.endMatch(!0)}endMatch(t){this.isPlaying=!1;const e=Date.now()-this.currentMatch.startTime,a={won:t,turns:this.currentMatch.turn,duration:e,cardsPlayed:this.stats.cardsPlayed,damageDealt:this.stats.damageDealt};t?(this.stats.matchesWon++,this.activeDeck.wins++):this.activeDeck.losses++;const s=300,r=t?500:0,n=Math.max(0,500-this.currentMatch.turn*10);return a.reward=s+r+n,window.gameEngine&&window.gameEngine.eventBus?.emit("cards:matchComplete",a),a}addCardToCollection(t,e=1){if(!this.cardDatabase.get(t))return!1;const s=this.playerCollection.get(t)||0;return this.playerCollection.set(t,s+e),this.stats.cardsCollected+=e,!0}openCardPack(t="standard"){const e=[],s={standard:{common:.71,uncommon:.23,rare:.05,epic:.01,legendary:.002},premium:{common:.5,uncommon:.3,rare:.15,epic:.04,legendary:.01}},r=s[t]||s.standard;for(let n=0;n<5;n++){const c=this.selectRarity(r),i=this.getRandomCard(c);e.push(i),this.addCardToCollection(i.id)}return e}selectRarity(t){const e=Math.random();let a=0;for(const[s,r]of Object.entries(t))if(a+=r,e<a)return s;return"common"}getRandomCard(t){const e=Array.from(this.cardDatabase.values()).filter(a=>a.rarity===t);return e[Math.floor(Math.random()*e.length)]}getStats(){return{...this.stats,winRate:this.stats.matchesPlayed>0?(this.stats.matchesWon/this.stats.matchesPlayed*100).toFixed(1):0,collectionSize:this.playerCollection.size,totalCards:Array.from(this.playerCollection.values()).reduce((t,e)=>t+e,0)}}}export{m as CardGameSystem};
