class c{constructor(){this.elementalMatrix=this.initializeElementalMatrix(),this.hitLocationMultipliers={HEAD:3,NECK:2.5,TORSO:1.5,ARM_LEFT:1.2,ARM_RIGHT:1.2,LEG_LEFT:1,LEG_RIGHT:1,HAND:1.3,FOOT:.8},this.criticalMultipliers={NORMAL:2,IMPROVED:2.5,DEADLY:3,DEVASTATING:4},this.damageTypes=["PHYSICAL","MAGICAL","TRUE","MIXED"]}initializeElementalMatrix(){return{FIRE:{strong:["NATURE","ICE","DARK"],weak:["WATER","HOLY"],neutral:["LIGHTNING","ARCANE","POISON"]},WATER:{strong:["FIRE","LIGHTNING"],weak:["NATURE","ICE"],neutral:["HOLY","DARK","ARCANE","POISON"]},ICE:{strong:["WATER","NATURE"],weak:["FIRE","HOLY"],neutral:["LIGHTNING","DARK","ARCANE","POISON"]},NATURE:{strong:["WATER","LIGHTNING"],weak:["FIRE","ICE","POISON"],neutral:["HOLY","DARK","ARCANE"]},LIGHTNING:{strong:["WATER","ARCANE"],weak:["NATURE"],neutral:["FIRE","ICE","HOLY","DARK","POISON"]},HOLY:{strong:["DARK","POISON"],weak:["ARCANE"],neutral:["FIRE","WATER","ICE","NATURE","LIGHTNING"]},DARK:{strong:["HOLY","ARCANE"],weak:["NATURE"],neutral:["FIRE","WATER","ICE","LIGHTNING","POISON"]},ARCANE:{strong:["HOLY","LIGHTNING"],weak:["DARK"],neutral:["FIRE","WATER","ICE","NATURE","POISON"]},POISON:{strong:["NATURE"],weak:["HOLY","FIRE"],neutral:["WATER","ICE","LIGHTNING","DARK","ARCANE"]}}}calculateDamage(e,t,i){let l=i.baseDamage;if(l*=this.getAttackerDamageMultiplier(e),i.element&&(l*=this.getElementalMultiplier(i.element,t.resistances)),i.damageType==="PHYSICAL"?l*=this.calculateArmorReduction(t.armor,e.armorPenetration||0):i.damageType==="MAGICAL"&&(l*=this.calculateMagicResistanceReduction(t.magicResist,e.magicPenetration||0)),i.isCritical){const a=i.criticalType||"NORMAL";l*=this.criticalMultipliers[a],i.hitLocation&&(l*=this.hitLocationMultipliers[i.hitLocation])}return i.comboCount>1&&(l*=this.getComboMultiplier(i.comboCount)),l*=this.getLevelScaling(e.level,t.level),l*=this.getStatusEffectMultiplier(t),i.isBackstab&&(l*=2.5),t.isVulnerable&&(l*=1.5),t.isBlocking&&!i.ignoresBlock&&(l*=.3),l=Math.max(l,i.baseDamage*.1),{finalDamage:Math.floor(l),isCritical:i.isCritical,damageType:i.damageType,element:i.element,breakdown:this.generateDamageBreakdown(i,l)}}calculateArmorReduction(e,t){const i=Math.max(0,e*(1-t/100)),l=i/(i+100);return Math.max(.1,1-l)}calculateMagicResistanceReduction(e,t){const i=Math.max(0,e*(1-t/100)),l=i/(i+100);return Math.max(.1,1-l)}getElementalMultiplier(e,t){let i=1;if(this.elementalMatrix[e],t&&t[e]){const l=t[e];i*=1-l/100}return Math.max(.1,i)}getElementalAdvantage(e,t){if(!e||!t)return 1;const i=this.elementalMatrix[e];return i.strong.includes(t)?1.5:i.weak.includes(t)?.75:1}getComboMultiplier(e){return e<=1?1:e===2?1.2:e===3?1.5:e===4?2:2.5}getLevelScaling(e,t){const i=e-t;return i>=10?1.5:i>=5?1.3:i>=0?1:i>=-5?.8:i>=-10?.6:.5}getAttackerDamageMultiplier(e){let t=1;return e.strength&&(t*=1+e.strength/100),e.buffs&&(e.buffs.EMPOWERED&&(t*=1.5),e.buffs.BERSERK&&(t*=2),e.buffs.WEAKENED&&(t*=.7)),t}getStatusEffectMultiplier(e){let t=1;return e.statusEffects&&(e.statusEffects.MARKED&&(t*=1.3),e.statusEffects.CURSED&&(t*=1.2),e.statusEffects.FORTIFIED&&(t*=.7)),t}calculateDoT(e,t,i,l=1){const a=Math.floor(t/i),r=e*l,s=r*a;return{damagePerTick:Math.floor(r),totalTicks:a,totalDamage:Math.floor(s),duration:t,tickRate:i}}calculateCritChance(e,t,i){let l=e;return t.critBonus&&(l+=t.critBonus),t.buffs&&t.buffs.INSPIRED&&(l+=.1),i.isVulnerable&&(l+=.2),t.targetingHead&&(l*=1.5),Math.min(l,.95)}calculatePenetrationEffectiveness(e,t){if(e>=t)return 1;const i=e/t;return Math.max(0,i)}applyDiminishingReturns(e,t,i=.75){return e<=0?0:e>=t?t:t*Math.pow(e/t,i)}generateDamageBreakdown(e,t){return{baseDamage:e.baseDamage,armorReduction:t<e.baseDamage,criticalBonus:e.isCritical,comboBonus:e.comboCount>1,elementalBonus:e.element!==void 0,finalDamage:Math.floor(t)}}calculateEffectiveHealth(e,t,i){const l=e/this.calculateArmorReduction(t,0),a=e/this.calculateMagicResistanceReduction(i,0);return{physical:Math.floor(l),magical:Math.floor(a),average:Math.floor((l+a)/2)}}calculateDPS(e,t){return e*t}calculateBurstDamage(e){let t=0,i=1;for(const l of e){const a=this.calculateDamage(l.attacker,l.defender,{...l,comboCount:i});t+=a.finalDamage,i++}return t}}export{c as DamageCalculationAdvanced};
