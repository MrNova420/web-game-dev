class c{constructor(t,e){this.enemy=t,this.engine=e,this.state="idle",this.previousState="idle",this.stateTimer=0,this.detectionRange=15,this.attackRange=3,this.fleeHealthThreshold=.2,this.patrolRadius=10,this.chaseSpeed=1.2,this.spawnPosition=t.mesh?t.mesh.position.clone():null,this.patrolPoints=[],this.currentPatrolIndex=0,this.patrolWaitTime=2,this.aggroTarget=null,this.aggroLevel=0,this.maxAggroDistance=25,this.lastAttackTime=0,this.attackCooldown=2,this.combatTimer=0,this.init()}init(){this.spawnPosition&&this.generatePatrolPoints()}generatePatrolPoints(){this.patrolPoints=[];for(let e=0;e<4;e++){const s=e/4*Math.PI*2,i=this.patrolRadius*(.5+Math.random()*.5);this.patrolPoints.push({x:this.spawnPosition.x+Math.cos(s)*i,z:this.spawnPosition.z+Math.sin(s)*i})}}update(t){if(!(!this.enemy.mesh||this.enemy.isDead)){switch(this.stateTimer+=t,this.combatTimer+=t,this.updateAggro(),this.state){case"idle":this.updateIdle(t);break;case"patrol":this.updatePatrol(t);break;case"chase":this.updateChase(t);break;case"attack":this.updateAttack(t);break;case"flee":this.updateFlee(t);break}this.checkStateTransitions()}}updateAggro(){const t=this.engine.player;if(!t||!t.mesh)return;const e=this.getDistanceToPlayer();e<this.detectionRange&&!this.aggroTarget&&(this.aggroTarget=t,this.aggroLevel=100,this.changeState("chase")),this.aggroTarget&&e>this.maxAggroDistance&&(this.aggroLevel=0,this.aggroTarget=null,this.changeState("patrol")),this.aggroLevel>0&&this.state!=="chase"&&this.state!=="attack"&&(this.aggroLevel=Math.max(0,this.aggroLevel-10*(1/60)))}updateIdle(t){this.stateTimer>3&&this.changeState("patrol")}updatePatrol(t){if(this.patrolPoints.length===0){this.changeState("idle");return}const e=this.patrolPoints[this.currentPatrolIndex],s=e.x-this.enemy.mesh.position.x,i=e.z-this.enemy.mesh.position.z,a=Math.sqrt(s*s+i*i);if(a<1)this.stateTimer>this.patrolWaitTime&&(this.currentPatrolIndex=(this.currentPatrolIndex+1)%this.patrolPoints.length,this.stateTimer=0);else{const n=(this.enemy.speed||2)*t,h=s/a,o=i/a;this.enemy.mesh.position.x+=h*n,this.enemy.mesh.position.z+=o*n,this.enemy.mesh.rotation.y=Math.atan2(s,i)}}updateChase(t){const e=this.engine.player;if(!e||!e.mesh){this.changeState("patrol");return}const s=this.getDistanceToPlayer(),i=e.mesh.position.x-this.enemy.mesh.position.x,a=e.mesh.position.z-this.enemy.mesh.position.z,n=(this.enemy.speed||2)*this.chaseSpeed*t,h=i/s,o=a/s;this.enemy.mesh.position.x+=h*n,this.enemy.mesh.position.z+=o*n,this.enemy.mesh.rotation.y=Math.atan2(i,a),s<this.attackRange&&this.changeState("attack")}updateAttack(t){const e=this.engine.player;if(!e||!e.mesh){this.changeState("patrol");return}const s=this.getDistanceToPlayer(),i=e.mesh.position.x-this.enemy.mesh.position.x,a=e.mesh.position.z-this.enemy.mesh.position.z;this.enemy.mesh.rotation.y=Math.atan2(i,a);const n=Date.now()/1e3;n-this.lastAttackTime>this.attackCooldown&&(this.performAttack(),this.lastAttackTime=n),s>this.attackRange+1&&this.changeState("chase")}updateFlee(t){const e=this.engine.player;if(!e||!e.mesh){this.changeState("patrol");return}const s=this.enemy.mesh.position.x-e.mesh.position.x,i=this.enemy.mesh.position.z-e.mesh.position.z,a=Math.sqrt(s*s+i*i);if(a<.1)return;const n=(this.enemy.speed||2)*1.5*t,h=s/a,o=i/a;this.enemy.mesh.position.x+=h*n,this.enemy.mesh.position.z+=o*n,this.enemy.mesh.rotation.y=Math.atan2(s,i),a>this.detectionRange&&this.changeState("patrol")}checkStateTransitions(){const t=this.engine.player;if(!t)return;if(this.enemy.stats.hp/this.enemy.stats.maxHp<this.fleeHealthThreshold&&this.state!=="flee"){this.changeState("flee");return}const s=this.getDistanceToPlayer();(this.state==="idle"||this.state==="patrol")&&s<this.detectionRange&&(this.aggroTarget=t,this.changeState("chase"))}performAttack(){const t=this.engine.player;if(!t)return;const e=this.enemy.stats?.attack||10;if(t.takeDamage&&t.takeDamage(e),this.engine.audioSystem&&this.engine.audioSystem.playSoundEffect("hit"),this.engine.particleSystem&&this.enemy.mesh&&this.engine.particleSystem.createHitEffect(this.enemy.mesh.position,16729156),this.enemy.mesh){const s=this.enemy.mesh.scale.clone();this.enemy.mesh.scale.multiplyScalar(1.3),setTimeout(()=>{this.enemy.mesh&&this.enemy.mesh.scale.copy(s)},100)}}changeState(t){this.state!==t&&(this.previousState=this.state,this.state=t,this.stateTimer=0,t==="patrol"&&this.patrolPoints.length===0&&this.generatePatrolPoints())}getDistanceToPlayer(){const t=this.engine.player;if(!t||!t.mesh||!this.enemy.mesh)return 1/0;const e=t.mesh.position.x-this.enemy.mesh.position.x,s=t.mesh.position.z-this.enemy.mesh.position.z;return Math.sqrt(e*e+s*s)}onDamaged(t,e){this.aggroLevel=100,this.aggroTarget=e,(this.state==="idle"||this.state==="patrol")&&this.changeState("chase")}getDebugInfo(){return{state:this.state,aggroLevel:this.aggroLevel,distanceToPlayer:this.getDistanceToPlayer().toFixed(1),patrolPoint:this.currentPatrolIndex}}}export{c as EnemyAI};
