class h{constructor(e){this.gameEngine=e,this.activeEffects=new Map,this.effectTypes=this.createEffectTypes(),this.stackingRules={poison:{maxStacks:5,refreshDuration:!0},burn:{maxStacks:3,refreshDuration:!0},bleed:{maxStacks:10,refreshDuration:!1},slow:{maxStacks:1,refreshDuration:!0},stun:{maxStacks:1,refreshDuration:!0},freeze:{maxStacks:1,refreshDuration:!1},regen:{maxStacks:1,refreshDuration:!0},shield:{maxStacks:1,refreshDuration:!1},haste:{maxStacks:3,refreshDuration:!0},strength:{maxStacks:5,refreshDuration:!0},weakness:{maxStacks:5,refreshDuration:!0},vulnerability:{maxStacks:3,refreshDuration:!0},immunity:{maxStacks:1,refreshDuration:!0},lifesteal:{maxStacks:1,refreshDuration:!0},thorns:{maxStacks:3,refreshDuration:!0}}}createEffectTypes(){return{poison:{name:"Poison",type:"debuff",damagePerSecond:5,duration:10,color:"#00ff00",icon:"☠️",particle:"poison"},burn:{name:"Burning",type:"debuff",damagePerSecond:8,duration:6,color:"#ff6600",icon:"🔥",particle:"fire"},bleed:{name:"Bleeding",type:"debuff",damagePerSecond:3,duration:15,color:"#cc0000",icon:"💉",particle:"blood"},slow:{name:"Slowed",type:"debuff",speedMultiplier:.5,duration:5,color:"#6699ff",icon:"❄️",particle:"ice"},stun:{name:"Stunned",type:"debuff",speedMultiplier:0,canAct:!1,duration:2,color:"#ffff00",icon:"⚡",particle:"stun"},freeze:{name:"Frozen",type:"debuff",speedMultiplier:0,canAct:!1,duration:3,color:"#00ccff",icon:"❄️",particle:"freeze"},haste:{name:"Haste",type:"buff",speedMultiplier:1.5,duration:10,color:"#ffcc00",icon:"⚡",particle:"speed"},regen:{name:"Regeneration",type:"buff",healPerSecond:5,duration:10,color:"#00ff00",icon:"💚",particle:"heal"},shield:{name:"Shield",type:"buff",absorbAmount:100,duration:15,color:"#6666ff",icon:"🛡️",particle:"shield"},strength:{name:"Strength",type:"buff",damageMultiplier:1.2,duration:15,color:"#ff0000",icon:"💪",particle:"power"},weakness:{name:"Weakness",type:"debuff",damageMultiplier:.7,duration:10,color:"#999999",icon:"💔",particle:"weakness"},vulnerability:{name:"Vulnerability",type:"debuff",damageTakenMultiplier:1.5,duration:8,color:"#ff00ff",icon:"💢",particle:"vulnerability"},immunity:{name:"Immunity",type:"buff",immuneToDebuffs:!0,duration:5,color:"#ffffff",icon:"✨",particle:"immunity"},lifesteal:{name:"Lifesteal",type:"buff",lifestealPercent:.15,duration:12,color:"#cc00cc",icon:"🩸",particle:"lifesteal"},thorns:{name:"Thorns",type:"buff",reflectPercent:.3,duration:10,color:"#996633",icon:"🌵",particle:"thorns"}}}applyEffect(e,t,i=null,s=1,f=null){const a=this.effectTypes[t];if(!a||this.hasImmunity(e))return!1;this.activeEffects.has(e)||this.activeEffects.set(e,[]);const c=this.activeEffects.get(e),n=c.find(r=>r.type===t),o=this.stackingRules[t];if(n){if(o){const r=n.stacks||1;r<o.maxStacks&&(n.stacks=r+1),o.refreshDuration&&(n.duration=i||a.duration,n.timer=0)}}else{const r={type:t,...a,duration:i||a.duration,timer:0,power:s,source:f,stacks:1,shieldRemaining:a.absorbAmount||0};c.push(r),this.showEffectApplied(e,r)}return!0}removeEffect(e,t){if(!this.activeEffects.has(e))return;const i=this.activeEffects.get(e),s=i.findIndex(f=>f.type===t);if(s!==-1){const f=i[s];i.splice(s,1),this.showEffectRemoved(e,f),i.length===0&&this.activeEffects.delete(e)}}update(e){for(const[t,i]of this.activeEffects){if(!t||t.health<=0){this.activeEffects.delete(t);continue}for(let s=i.length-1;s>=0;s--){const f=i[s];f.timer+=e,this.applyEffectTick(t,f,e),f.timer>=f.duration&&(this.showEffectExpired(t,f),i.splice(s,1))}i.length===0&&this.activeEffects.delete(t)}}applyEffectTick(e,t,i){const s=t.stacks||1;if(t.damagePerSecond){const f=t.damagePerSecond*s*t.power*i;e.health-=f,e.health<0&&(e.health=0),Math.random()<.1&&this.gameEngine.particleSystem&&this.gameEngine.particleSystem.createDOTEffect(e.position,t.particle)}if(t.healPerSecond){const f=t.healPerSecond*s*t.power*i;e.health+=f,e.health>e.maxHealth&&(e.health=e.maxHealth),Math.random()<.1&&this.gameEngine.particleSystem&&this.gameEngine.particleSystem.createHealEffect(e.position)}}getSpeedMultiplier(e){if(!this.activeEffects.has(e))return 1;let t=1;const i=this.activeEffects.get(e);for(const s of i)s.speedMultiplier!==void 0&&(t*=s.speedMultiplier);return t}getDamageMultiplier(e){if(!this.activeEffects.has(e))return 1;let t=1;const i=this.activeEffects.get(e);for(const s of i)if(s.damageMultiplier!==void 0){const f=s.stacks||1,a=(s.damageMultiplier-1)*f;t*=1+a}return t}getDamageTakenMultiplier(e){if(!this.activeEffects.has(e))return 1;let t=1;const i=this.activeEffects.get(e);for(const s of i)s.damageTakenMultiplier!==void 0&&(t*=s.damageTakenMultiplier);return t}processDamage(e,t,i=null){if(!this.activeEffects.has(e))return t;const s=this.activeEffects.get(e);let f=t;f*=this.getDamageTakenMultiplier(e);for(const a of s)if(a.type==="shield"&&a.shieldRemaining>0){const c=Math.min(f,a.shieldRemaining);if(a.shieldRemaining-=c,f-=c,a.shieldRemaining<=0&&this.removeEffect(e,"shield"),this.gameEngine.particleSystem&&this.gameEngine.particleSystem.createShieldBlockEffect(e.position),f<=0)break}if(i){for(const a of s)if(a.type==="thorns"){const c=t*a.reflectPercent*(a.stacks||1);i.health-=c,this.gameEngine.particleSystem&&this.gameEngine.particleSystem.createThornsEffect(i.position)}}return Math.max(0,f)}processLifesteal(e,t){if(!this.activeEffects.has(e))return 0;const i=this.activeEffects.get(e);let s=0;for(const f of i)if(f.type==="lifesteal"){const a=t*f.lifestealPercent;e.health+=a,s+=a,e.health>e.maxHealth&&(e.health=e.maxHealth),this.gameEngine.particleSystem&&this.gameEngine.particleSystem.createLifestealEffect(e.position)}return s}canAct(e){if(!this.activeEffects.has(e))return!0;const t=this.activeEffects.get(e);for(const i of t)if(i.canAct===!1)return!1;return!0}hasImmunity(e){return this.activeEffects.has(e)?this.activeEffects.get(e).some(i=>i.type==="immunity"):!1}hasEffect(e,t){return this.activeEffects.has(e)?this.activeEffects.get(e).some(s=>s.type===t):!1}getEffectStacks(e,t){if(!this.activeEffects.has(e))return 0;const s=this.activeEffects.get(e).find(f=>f.type===t);return s?s.stacks||1:0}clearAllEffects(e){if(this.activeEffects.has(e)){const t=this.activeEffects.get(e);t.length=0,this.activeEffects.delete(e)}}clearEffectsByType(e,t){if(!this.activeEffects.has(e))return;const i=this.activeEffects.get(e);for(let s=i.length-1;s>=0;s--)i[s].type===t&&i.splice(s,1);i.length===0&&this.activeEffects.delete(e)}getActiveEffects(e){return this.activeEffects.get(e)||[]}showEffectApplied(e,t){this.gameEngine.particleSystem&&this.gameEngine.particleSystem.createStatusEffect(e.position,t.particle),this.gameEngine.audioSystem&&this.gameEngine.audioSystem.playSoundEffect("status_applied")}showEffectRemoved(e,t){}showEffectExpired(e,t){}checkCombinations(e){if(!this.activeEffects.has(e))return;const i=this.activeEffects.get(e).map(s=>s.type);i.includes("burn")&&i.includes("poison"),i.includes("freeze")}getEffectDescription(e){const t=this.effectTypes[e];if(!t)return"";let i=t.name+": ";if(t.damagePerSecond&&(i+=`${t.damagePerSecond} damage/sec`),t.healPerSecond&&(i+=`${t.healPerSecond} healing/sec`),t.speedMultiplier!==void 0&&t.speedMultiplier!==1){const s=Math.round((t.speedMultiplier-1)*100);i+=`${s>0?"+":""}${s}% speed`}if(t.damageMultiplier!==void 0){const s=Math.round((t.damageMultiplier-1)*100);i+=`${s>0?"+":""}${s}% damage`}return i}}export{h as StatusEffectsSystem};
