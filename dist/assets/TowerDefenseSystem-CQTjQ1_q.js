import{j as n}from"./three-DTQjiZ7L.js";class c{constructor(e){this.scene=e,this.isPlaying=!1,this.currentWave=0,this.lives=20,this.gold=500,this.score=0,this.towers=[],this.towerTypes=this.initializeTowerTypes(),this.enemies=[],this.enemyTypes=this.initializeEnemyTypes(),this.currentMap=null,this.path=[],this.grid=null,this.waveSchedule=[],this.waveTimer=0,this.timeBetweenWaves=3e4,this.stats={wavesCompleted:0,enemiesKilled:0,towersBuilt:0,totalDamageDealt:0,goldEarned:0,highestWave:0}}initializeTowerTypes(){return{archer:{name:"Archer Tower",cost:100,damage:10,range:5,attackSpeed:1,projectileSpeed:10,upgrades:["damage","range","speed"],maxLevel:3},mage:{name:"Mage Tower",cost:150,damage:15,range:6,attackSpeed:.8,projectileSpeed:8,element:"arcane",splashRadius:1.5,upgrades:["damage","splash","slow"],maxLevel:3},cannon:{name:"Cannon Tower",cost:200,damage:30,range:4,attackSpeed:.5,projectileSpeed:6,splashRadius:2,upgrades:["damage","range","splash"],maxLevel:3},lightning:{name:"Lightning Tower",cost:250,damage:25,range:7,attackSpeed:1.5,chainTargets:3,element:"lightning",upgrades:["damage","chain","stun"],maxLevel:3},frost:{name:"Frost Tower",cost:180,damage:8,range:5,attackSpeed:1.2,slowAmount:.5,slowDuration:3e3,element:"ice",upgrades:["slow","range","freeze"],maxLevel:3},poison:{name:"Poison Tower",cost:220,damage:5,dps:10,dotDuration:5e3,range:5,attackSpeed:1,element:"poison",upgrades:["dps","duration","range"],maxLevel:3},buff:{name:"Buff Tower",cost:300,buffRange:4,damageBonus:.25,speedBonus:.2,upgrades:["damage_bonus","speed_bonus","range"],maxLevel:3},omega:{name:"Omega Tower",cost:1e3,damage:100,range:10,attackSpeed:2,chainTargets:5,splashRadius:3,allElements:!0,upgrades:["ultimate"],maxLevel:1}}}initializeEnemyTypes(){return{slime:{name:"Slime",health:50,speed:2,armor:0,reward:10,element:"nature"},goblin:{name:"Goblin",health:80,speed:2.5,armor:5,reward:15,element:"none"},skeleton:{name:"Skeleton",health:100,speed:2.2,armor:10,reward:20,element:"dark"},orc:{name:"Orc Warrior",health:200,speed:1.8,armor:20,reward:30,element:"none"},mage:{name:"Enemy Mage",health:120,speed:2,armor:5,shield:50,reward:35,element:"arcane"},wolf:{name:"Shadow Wolf",health:60,speed:4,armor:0,reward:25,element:"dark"},golem:{name:"Stone Golem",health:500,speed:1,armor:50,reward:80,element:"earth"},bat:{name:"Vampire Bat",health:40,speed:3.5,armor:0,flying:!0,reward:20,element:"dark"},dragon:{name:"Dragon",health:2e3,speed:1.5,armor:100,shield:500,reward:500,boss:!0,element:"fire"}}}startGame(e){return this.isPlaying=!0,this.currentWave=0,this.lives=20,this.gold=500,this.score=0,this.loadMap(e),this.generateWaveSchedule(),!0}loadMap(e){this.currentMap={id:e,name:"Crystal Caverns Defense",size:{width:20,height:15},startPoint:new n(0,7),endPoint:new n(19,7),path:this.generatePath()},this.path=this.currentMap.path,this.grid=this.createGrid(this.currentMap.size)}generatePath(){const e=[];for(let t=0;t<=19;t++)e.push(new n(t,7));return e}createGrid(e){const t=[];for(let s=0;s<e.height;s++){t[s]=[];for(let a=0;a<e.width;a++){const i=this.path.some(r=>r.x===a&&r.y===s);t[s][a]={x:a,y:s,occupied:i,isPath:i,tower:null}}}return t}generateWaveSchedule(){this.waveSchedule=[];for(let e=1;e<=50;e++){const t=this.generateWaveEnemies(e);this.waveSchedule.push({wave:e,enemies:t,delay:1e3})}}generateWaveEnemies(e){const t=[],s=5+e*2;for(let a=0;a<s;a++){let i;e<5?i="slime":e<10?i=Math.random()<.5?"slime":"goblin":e<15?i=["slime","goblin","skeleton"][Math.floor(Math.random()*3)]:e<25?i=["goblin","skeleton","orc","wolf"][Math.floor(Math.random()*4)]:i=["orc","wolf","golem","bat","mage"][Math.floor(Math.random()*5)],t.push(i)}return e%10===0&&t.push("dragon"),t}buildTower(e,t,s){const a=this.towerTypes[s];if(!a||this.gold<a.cost||!this.isValidPlacement(e,t))return!1;const i={id:Math.random().toString(36),type:s,position:new n(e,t),level:1,...a,target:null,lastAttackTime:0,kills:0};return this.towers.push(i),this.grid[t][e].occupied=!0,this.grid[t][e].tower=i,this.gold-=a.cost,this.stats.towersBuilt++,i}isValidPlacement(e,t){if(e<0||e>=this.currentMap.size.width||t<0||t>=this.currentMap.size.height)return!1;const s=this.grid[t][e];return!s.occupied&&!s.isPath}upgradeTower(e,t){const s=this.towers.find(i=>i.id===e);if(!s||s.level>=s.maxLevel)return!1;const a=s.cost*s.level;return this.gold<a?!1:(s.level++,this.applyUpgrade(s,t),this.gold-=a,!0)}applyUpgrade(e,t){switch(t){case"damage":e.damage*=1.5;break;case"range":e.range*=1.3;break;case"speed":e.attackSpeed*=1.4;break;case"splash":e.splashRadius*=1.5;break;case"chain":e.chainTargets++;break;case"slow":e.slowAmount*=1.2;break}}spawnWave(){if(this.currentWave>=this.waveSchedule.length){this.victory();return}const e=this.waveSchedule[this.currentWave];this.currentWave++;let t=0;for(const s of e.enemies)setTimeout(()=>{this.spawnEnemy(s)},t),t+=e.delay}spawnEnemy(e){const t=this.enemyTypes[e];if(!t)return;const s={id:Math.random().toString(36),type:e,...t,currentHealth:t.health*(1+this.currentWave*.1),position:this.path[0].clone(),pathIndex:0,statusEffects:[]};this.enemies.push(s)}update(e){this.isPlaying&&(this.updateTowers(e),this.updateEnemies(e),this.enemies.length===0&&this.currentWave<this.waveSchedule.length&&(this.waveTimer+=e*1e3,this.waveTimer>=this.timeBetweenWaves&&(this.waveTimer=0,this.spawnWave())))}updateTowers(e){const t=Date.now();for(const s of this.towers)if((!s.target||!this.isEnemyAlive(s.target))&&(s.target=this.findTarget(s)),s.target){const a=1e3/s.attackSpeed;t-s.lastAttackTime>=a&&(this.towerAttack(s,s.target),s.lastAttackTime=t)}}findTarget(e){let t=null,s=-1;for(const a of this.enemies)e.position.distanceTo(new n(a.position.x,a.position.y))<=e.range&&a.pathIndex>s&&(s=a.pathIndex,t=a);return t}towerAttack(e,t){let s=e.damage;s=Math.max(1,s-t.armor),this.damageEnemy(t,s,e),e.chainTargets&&this.chainAttack(e,t,e.chainTargets-1,s*.7),e.splashRadius&&this.splashDamage(t,e.splashRadius,s*.5),e.slowAmount&&this.applyStatusEffect(t,"slow",e.slowDuration,e.slowAmount),e.dps&&this.applyStatusEffect(t,"poison",e.dotDuration,e.dps)}damageEnemy(e,t,s){e.currentHealth-=t,this.stats.totalDamageDealt+=t,e.currentHealth<=0&&this.killEnemy(e,s)}killEnemy(e,t){const s=this.enemies.indexOf(e);s>-1&&this.enemies.splice(s,1),this.gold+=e.reward,this.stats.goldEarned+=e.reward,this.score+=e.reward*10,t&&t.kills++,this.stats.enemiesKilled++}chainAttack(e,t,s,a){if(s<=0)return;let i=null,r=1/0;for(const o of this.enemies){if(o===t)continue;const h=new n(t.position.x,t.position.y).distanceTo(new n(o.position.x,o.position.y));h<r&&h<=3&&(r=h,i=o)}i&&(this.damageEnemy(i,a,e),this.chainAttack(e,i,s-1,a*.7))}splashDamage(e,t,s){for(const a of this.enemies){if(a===e)continue;new n(e.position.x,e.position.y).distanceTo(new n(a.position.x,a.position.y))<=t&&this.damageEnemy(a,s,null)}}applyStatusEffect(e,t,s,a){e.statusEffects.push({type:t,duration:s,value:a,remaining:s})}updateEnemies(e){for(const t of[...this.enemies]){this.updateStatusEffects(t,e);let s=t.speed;for(const a of t.statusEffects)a.type==="slow"&&(s*=1-a.value);for(const a of t.statusEffects)a.type==="poison"&&this.damageEnemy(t,a.value*e,null);if(t.pathIndex<this.path.length-1){const a=this.path[t.pathIndex+1],i=new n().subVectors(a,t.position).normalize();t.position.add(i.multiplyScalar(s*e)),t.position.distanceTo(a)<.5&&t.pathIndex++}else this.loseLife(t)}}updateStatusEffects(e,t){e.statusEffects=e.statusEffects.filter(s=>(s.remaining-=t*1e3,s.remaining>0))}loseLife(e){this.lives--;const t=this.enemies.indexOf(e);t>-1&&this.enemies.splice(t,1),this.lives<=0&&this.defeat()}isEnemyAlive(e){return this.enemies.includes(e)&&e.currentHealth>0}victory(){this.isPlaying=!1,this.stats.wavesCompleted=this.currentWave,this.stats.highestWave=Math.max(this.stats.highestWave,this.currentWave);const e={victory:!0,wave:this.currentWave,score:this.score,livesRemaining:this.lives,goldRemaining:this.gold,reward:this.score*10+this.gold};return window.gameEngine&&window.gameEngine.eventBus?.emit("towerDefense:victory",e),e}defeat(){this.isPlaying=!1,this.stats.wavesCompleted=this.currentWave-1,this.stats.highestWave=Math.max(this.stats.highestWave,this.currentWave-1);const e={victory:!1,wave:this.currentWave,score:this.score,reward:Math.floor(this.score*.5)};return window.gameEngine&&window.gameEngine.eventBus?.emit("towerDefense:defeat",e),e}getStats(){return{...this.stats}}}export{c as TowerDefenseSystem};
