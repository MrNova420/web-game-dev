class u{constructor(t,e){this.combatSystem=t,this.physics=e,this.enemies=new Map,this.squads=new Map,this.behaviors=new Map,this.initializeBehaviors()}initializeBehaviors(){this.behaviors.set("aggressive",{name:"Aggressive",engageRange:15,retreatThreshold:.2,attackFrequency:1,circlePlayer:!1,useSkills:!0,tactics:["rush","relentless_attack"]}),this.behaviors.set("defensive",{name:"Defensive",engageRange:10,retreatThreshold:.5,attackFrequency:.6,circlePlayer:!0,useSkills:!0,tactics:["block","counter","retreat_heal"]}),this.behaviors.set("tactical",{name:"Tactical",engageRange:12,retreatThreshold:.3,attackFrequency:.8,circlePlayer:!0,useSkills:!0,tactics:["flank","coordinate","use_environment"]}),this.behaviors.set("ranged",{name:"Ranged",engageRange:20,retreatThreshold:.4,attackFrequency:.7,circlePlayer:!0,useSkills:!0,tactics:["kite","maintain_distance","use_cover"]}),this.behaviors.set("support",{name:"Support",engageRange:15,retreatThreshold:.6,attackFrequency:.3,circlePlayer:!1,useSkills:!0,tactics:["buff_allies","heal","debuff_player"]}),this.behaviors.set("ambush",{name:"Ambush",engageRange:8,retreatThreshold:.1,attackFrequency:1.2,circlePlayer:!1,useSkills:!0,tactics:["stealth","backstab","burst_damage"]})}registerEnemy(t,e,a="aggressive"){const s=this.behaviors.get(a)||this.behaviors.get("aggressive");this.enemies.set(t,{id:t,data:e,behavior:s,behaviorType:a,state:"idle",target:null,lastAttackTime:0,lastSkillTime:0,position:e.position||{x:0,y:0,z:0},destination:null,patrolPoints:[],currentPatrolIndex:0,health:e.maxHealth||100,maxHealth:e.maxHealth||100,inCombat:!1,lastDamagedTime:0,alertLevel:0,canSeePlayer:!1,lastSeenPlayerPos:null,hearingRange:15,sightRange:20,decisionTimer:0,currentTactic:null,squadId:null,isLeader:!1,skillCooldowns:new Map})}createSquad(t,e,a=null){this.squads.set(t,{id:t,members:e,leader:a||e[0],formation:"spread",tactic:null}),e.forEach(s=>{const i=this.enemies.get(s);i&&(i.squadId=t,i.isLeader=s===(a||e[0]))})}update(t,e){this.enemies.forEach(a=>{a.state!=="dead"&&(a.decisionTimer-=t,this.updateAwareness(a,e),a.decisionTimer<=0&&(this.makeDecision(a,e),a.decisionTimer=.5),this.executeBehavior(a,e,t),a.squadId&&this.updateSquadTactics(a.squadId,e))})}updateAwareness(t,e){const a=this.getDistance(t.position,e);t.canSeePlayer=a<=t.sightRange&&this.hasLineOfSight(t.position,e),t.canSeePlayer?(t.lastSeenPlayerPos={...e},t.alertLevel=Math.min(100,t.alertLevel+5)):t.alertLevel=Math.max(0,t.alertLevel-1),a<=t.hearingRange&&(t.alertLevel=Math.max(t.alertLevel,50)),Date.now()-t.lastDamagedTime<1e3&&(t.alertLevel=100,t.lastSeenPlayerPos={...e})}makeDecision(t,e){const a=this.getDistance(t.position,e),s=t.health/t.maxHealth;if(t.health<=0){t.state="dead";return}if(s<t.behavior.retreatThreshold&&t.inCombat){t.state="retreat";return}if(t.alertLevel>50&&t.canSeePlayer){a>t.behavior.engageRange*.7?(t.state="chase",t.target=e):(t.state="attack",t.target=e),t.inCombat=!0;return}if(t.alertLevel>30&&!t.canSeePlayer&&t.lastSeenPlayerPos){t.state="chase",t.target=t.lastSeenPlayerPos;return}t.alertLevel===0&&(t.patrolPoints.length>0?t.state="patrol":t.state="idle",t.inCombat=!1)}executeBehavior(t,e,a){switch(t.state){case"idle":this.executeIdle(t,a);break;case"patrol":this.executePatrol(t,a);break;case"chase":this.executeChase(t,e,a);break;case"attack":this.executeAttack(t,e,a);break;case"retreat":this.executeRetreat(t,e,a);break}}executeIdle(t,e){}executePatrol(t,e){if(t.patrolPoints.length===0){t.state="idle";return}const a=t.patrolPoints[t.currentPatrolIndex];this.getDistance(t.position,a)<2?t.currentPatrolIndex=(t.currentPatrolIndex+1)%t.patrolPoints.length:this.moveTowards(t,a,e)}executeChase(t,e,a){const s=t.target||e;this.getDistance(t.position,s)<t.behavior.engageRange*.7?t.state="attack":this.moveTowards(t,s,a)}executeAttack(t,e,a){const s=this.getDistance(t.position,e),i=Date.now();t.behavior.circlePlayer?this.circleTarget(t,e,t.behavior.engageRange*.8,a):s>t.behavior.engageRange*.5?this.moveTowards(t,e,a):s<t.behavior.engageRange*.3&&this.moveAway(t,e,a);const c=1e3/t.behavior.attackFrequency;s<=t.data.attackRange&&i-t.lastAttackTime>c&&(this.performAttack(t,e),t.lastAttackTime=i),t.behavior.useSkills&&i-t.lastSkillTime>3e3&&(this.useSkill(t,e),t.lastSkillTime=i),t.behavior.tactics.length>0&&this.executeTactic(t,e)}executeRetreat(t,e,a){this.moveAway(t,e,a),t.health/t.maxHealth>t.behavior.retreatThreshold+.2&&(t.state="chase")}performAttack(t,e){this.combatSystem.attack(t.id,"player",{attackType:t.data.attackType||"melee",damage:t.data.damage||10,element:t.data.element||"physical",canCrit:!0})}useSkill(t,e){if(!t.data.skills||t.data.skills.length===0)return;const a=t.data.skills.filter(s=>{const i=t.skillCooldowns.get(s.id)||0;return Date.now()>i});if(a.length>0){const s=a[Math.floor(Math.random()*a.length)];this.combatSystem.attack(t.id,"player",{attackType:s.type||"magic",damage:s.damage||15,element:s.element||"fire",canCrit:!1,isSkill:!0}),t.skillCooldowns.set(s.id,Date.now()+(s.cooldown||5e3))}}executeTactic(t,e){switch(t.currentTactic||t.behavior.tactics[0]){case"flank":this.moveToFlank(t,e);break;case"kite":this.getDistance(t.position,e)<t.behavior.engageRange*.8&&this.moveAway(t,e,.016);break}}updateSquadTactics(t,e){const a=this.squads.get(t);if(!a)return;const s=this.enemies.get(a.leader);if(!s||s.state==="dead"){const i=a.members.filter(c=>{const r=this.enemies.get(c);return r&&r.state!=="dead"});i.length>0&&(a.leader=i[0]);return}s.inCombat&&a.members.forEach((i,c)=>{const r=this.enemies.get(i);if(!(!r||r.state==="dead"||r.id===s.id))switch(a.formation){case"spread":const o=c/a.members.length*Math.PI*2;r.destination={x:e.x+Math.cos(o)*8,y:e.y,z:e.z+Math.sin(o)*8};break;case"line":r.destination={x:s.position.x+(c-a.members.length/2)*3,y:s.position.y,z:s.position.z};break}})}getDistance(t,e){const a=t.x-e.x,s=t.z-e.z;return Math.sqrt(a*a+s*s)}hasLineOfSight(t,e){return this.physics?!this.physics.raycast(t,e).hasHit:!0}moveTowards(t,e,a){const s=t.data.moveSpeed||5,i=e.x-t.position.x,c=e.z-t.position.z,r=Math.sqrt(i*i+c*c);r>.1&&(t.position.x+=i/r*s*a,t.position.z+=c/r*s*a)}moveAway(t,e,a){const s=t.data.moveSpeed||5,i=t.position.x-e.x,c=t.position.z-e.z,r=Math.sqrt(i*i+c*c);r>.1&&(t.position.x+=i/r*s*a,t.position.z+=c/r*s*a)}circleTarget(t,e,a,s){const i=t.data.moveSpeed||5,c=t.position.x-e.x,r=t.position.z-e.z,o=Math.sqrt(c*c+r*r),l=-r,h=c,n=Math.sqrt(l*l+h*h);if(n>0&&(t.position.x+=l/n*i*s,t.position.z+=h/n*i*s),Math.abs(o-a)>1){const d=(o>a?-1:1)*i*.5;t.position.x+=c/o*d*s,t.position.z+=r/o*d*s}}moveToFlank(t,e){const a=Math.random()*Math.PI*2;t.destination={x:e.x+Math.cos(a)*5,y:e.y,z:e.z+Math.sin(a)*5}}setPatrolPath(t,e){const a=this.enemies.get(t);a&&(a.patrolPoints=e,a.currentPatrolIndex=0)}takeDamage(t,e){const a=this.enemies.get(t);a&&(a.health=Math.max(0,a.health-e),a.lastDamagedTime=Date.now(),a.health<=0&&(a.state="dead"))}getEnemyState(t){return this.enemies.get(t)}removeEnemy(t){const e=this.enemies.get(t);if(e&&e.squadId){const a=this.squads.get(e.squadId);a&&(a.members=a.members.filter(s=>s!==t))}this.enemies.delete(t)}}export{u as AdvancedEnemyAISystem};
